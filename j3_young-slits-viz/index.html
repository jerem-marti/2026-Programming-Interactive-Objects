<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Young's Double-Slit — Quantum Observer</title>
	<style>
		* { box-sizing: border-box; margin: 0; padding: 0; }

		body {
			background: #1a1a2e;
			color: #e0e0e0;
			font-family: 'Courier New', monospace;
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 1.5em;
			gap: 1em;
		}

		h1 {
			font-size: 1.1em;
			color: #7fdbca;
			letter-spacing: 0.05em;
		}

		.row {
			display: flex;
			gap: 1.5em;
			align-items: flex-start;
			flex-wrap: wrap;
			justify-content: center;
		}

		.panel {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 0.4em;
		}

		.panel label {
			font-size: 0.75em;
			color: #888;
			text-transform: uppercase;
			letter-spacing: 0.1em;
		}

		/* Matrix preview canvas */
		#matrixCanvas {
			display: block;
			background: #000;
			image-rendering: pixelated;
			border: 2px solid #333;
		}

		/* Webcam feed */
		#webcam {
			transform: scaleX(-1);
			border: 2px solid #333;
			border-radius: 4px;
		}

		/* Status indicators */
		.status-bar {
			display: flex;
			gap: 1.5em;
			font-size: 0.8em;
			align-items: center;
		}

		.indicator {
			display: flex;
			align-items: center;
			gap: 0.4em;
		}

		.dot {
			width: 10px;
			height: 10px;
			border-radius: 50%;
			background: #555;
			transition: background 0.3s;
		}

		.dot.active { background: #7fdbca; }
		.dot.watching { background: #ff6b6b; }

		button {
			padding: 0.5em 1.2em;
			font-family: inherit;
			font-size: 0.85em;
			border: 1px solid #7fdbca;
			background: transparent;
			color: #7fdbca;
			cursor: pointer;
			border-radius: 3px;
			transition: background 0.2s;
		}

		button:hover { background: rgba(127, 219, 202, 0.15); }

		pre {
			font-size: 0.7em;
			color: #666;
			max-width: 60ch;
			white-space: pre-wrap;
		}

		.controls {
			display: flex;
			gap: 0.8em;
			align-items: center;
		}
	</style>
</head>
<body>

	<h1>Young's Double-Slit Experiment — Quantum Observer Effect</h1>

	<div class="status-bar">
		<div class="indicator">
			<div class="dot" id="dotSerial"></div>
			<span>Serial</span>
		</div>
		<div class="indicator">
			<div class="dot" id="dotCamera"></div>
			<span>Camera</span>
		</div>
		<div class="indicator">
			<div class="dot" id="dotFace"></div>
			<span id="faceLabel">No Observer</span>
		</div>
	</div>

	<div class="row">
		<div class="panel">
			<label>LED Matrix Preview (32 × 32)</label>
			<canvas id="matrixCanvas" width="32" height="32"></canvas>
		</div>
		<div class="panel">
			<label>Webcam + Face Detection</label>
			<video id="webcam" width="320" height="240" autoplay playsinline></video>
		</div>
	</div>

	<div class="controls">
		<button id="connectSerial">Connect Serial Port</button>
		<button id="startCamera">Start Camera</button>
	</div>

	<pre id="log">Click "Start Camera" then "Connect Serial Port" (Chrome only).</pre>

	<!-- ─── MediaPipe Face Detection via CDN ─── -->
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin></script>

	<script type="module">

		// ─────────────────────────────────────────
		//  Constants
		// ─────────────────────────────────────────
		const W = 32
		const H = 32
		const BAUD_RATE   = 921600
		const COLOR_DEPTH = 16            // 16-bit RGB565
		const TARGET_FPS  = 35
		const PIXEL_DATA  = new Uint8Array(1 + W * H * (COLOR_DEPTH / 8))

		// ─────────────────────────────────────────
		//  DOM refs
		// ─────────────────────────────────────────
		const canvas  = document.getElementById('matrixCanvas')
		const ctx     = canvas.getContext('2d', { willReadFrequently: true })
		canvas.style.width  = W * 10 + 'px'
		canvas.style.height = H * 10 + 'px'

		const video     = document.getElementById('webcam')
		const logEl     = document.getElementById('log')
		const dotSerial = document.getElementById('dotSerial')
		const dotCamera = document.getElementById('dotCamera')
		const dotFace   = document.getElementById('dotFace')
		const faceLabel = document.getElementById('faceLabel')

		// ─────────────────────────────────────────
		//  State
		// ─────────────────────────────────────────
		let writer       = null
		let writing      = false  // guard: true while a serial write is in flight
		let isObserved   = false  // debounced observation state
		let observeBlend = 0     // smooth 0‑1 blend toward observed state
		let frame = 0
		let timeSample = 0

		// ─────────────────────────────────────────
		//  Serial (Chrome Web Serial API)
		// ─────────────────────────────────────────
		document.getElementById('connectSerial').addEventListener('click', async () => {
			try {
				// Request serial port access
				const serialPort = await navigator.serial.requestPort()
				await serialPort.open({ baudRate: BAUD_RATE })
				writer = serialPort.writable.getWriter()
				dotSerial.classList.add('active')
				appendLog('Serial port connected.')
			} catch (err) {
				const error = 'Error opening serial port: ' + err
				appendLog(error)
				console.error(error)
				writer = null
			}
		})

		// ─────────────────────────────────────────
		//  Camera + MediaPipe Face Detection
		// ─────────────────────────────────────────
		document.getElementById('startCamera').addEventListener('click', async () => {
			try {
				const stream = await navigator.mediaDevices.getUserMedia({
					video: { width: 320, height: 240, facingMode: 'user' }
				})
				video.srcObject = stream
				dotCamera.classList.add('active')
				appendLog('Camera started.')
				initFaceDetection()
			} catch (e) {
				appendLog('Camera error: ' + e)
			}
		})

		function initFaceDetection() {
			const faceDetection = new FaceDetection({
				locateFile: file =>
					`https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
			})

			faceDetection.setOptions({
				model: 'short',
				minDetectionConfidence: 0.5
			})

			// ── Debounce: require N consecutive same-state results to flip ──
			const DEBOUNCE_COUNT = 3
			let consecutiveSame = 0
			let lastRawState = false

			faceDetection.onResults(results => {
				const faceNow = !!(results.detections && results.detections.length > 0)

				if (faceNow === lastRawState) {
					consecutiveSame++
				} else {
					consecutiveSame = 1
					lastRawState = faceNow
				}

				// Only flip the actual state after DEBOUNCE_COUNT consistent readings
				if (consecutiveSame >= DEBOUNCE_COUNT && isObserved !== faceNow) {
					isObserved = faceNow
				}

				// UI indicators (can be instant, just visual)
				if (isObserved) {
					dotFace.classList.add('watching')
					dotFace.classList.remove('active')
					faceLabel.textContent = 'Observer!'
				} else {
					dotFace.classList.remove('watching')
					dotFace.classList.add('active')
					faceLabel.textContent = 'No Observer'
				}
			})

			// Throttle face detection to ~4 fps
			const DETECT_INTERVAL = 250
			let detecting = false

			setInterval(async () => {
				if (detecting) return
				if (video.readyState < 2) return
				detecting = true
				try {
					await faceDetection.send({ image: video })
				} catch (e) { /* skip */ }
				detecting = false
			}, DETECT_INTERVAL)

			appendLog('Face detection initialised (throttled, debounced).')
		}

		// ─────────────────────────────────────────
		//  SDF helpers (inspired by Inigo Quilez)
		//  https://iquilezles.org/articles/distfunctions/
		// ─────────────────────────────────────────

		// Signed distance to an axis-aligned 2D box centred at (cx,cy)
		function sdBox(px, py, cx, cy, bx, by) {
			const qx = Math.abs(px - cx) - bx
			const qy = Math.abs(py - cy) - by
			const outside = Math.sqrt(Math.max(qx, 0) ** 2 + Math.max(qy, 0) ** 2)
			const inside  = Math.min(Math.max(qx, qy), 0)
			return outside + inside
		}

		// Signed distance to a circle centred at (cx,cy)
		function sdCircle(px, py, cx, cy, r) {
			const dx = px - cx, dy = py - cy
			return Math.sqrt(dx * dx + dy * dy) - r
		}

		// Smooth boolean union (IQ's updated formula)
		function opSmoothUnion(a, b, k) {
			k *= 4.0
			const h = Math.max(k - Math.abs(a - b), 0.0)
			return Math.min(a, b) - h * h * 0.25 / k
		}

		// Boolean subtraction: carve shape a out of shape b
		function opSubtraction(a, b) {
			return Math.max(-a, b)
		}

		// Hermite smooth-step
		function smoothstep(e0, e1, x) {
			const t = Math.max(0, Math.min(1, (x - e0) / (e1 - e0)))
			return t * t * (3 - 2 * t)
		}

		function clampf(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v }
		function lerp(a, b, t) { return a + (b - a) * t }
		function saturate(v) { return clampf(v, 0, 1) }

		// ─────────────────────────────────────────
		//  Experiment geometry (normalised coords -1…+1)
		// ─────────────────────────────────────────

		const BARRIER_U   = -0.55     // barrier x position
		const BARRIER_HW  = 0.06      // barrier half-width
		const SLIT_V1     = -0.32     // slit 1 centre y
		const SLIT_V2     =  0.32     // slit 2 centre y
		const SLIT_HH     = 0.07      // slit half-height
		const SOURCE_U    = -0.88     // source x position

		// Wave parameters
		const WAVE_K      = 22.0      // spatial frequency (wave-number)
		const WAVE_SPEED  = 4.0       // temporal speed

		// ─────────────────────────────────────────
		//  Photon particles
		// ─────────────────────────────────────────
		const MAX_PHOTONS = 60
		const photons = []

		function spawnPhoton() {
			// Through one slit at random
			const slitV = Math.random() < 0.5 ? SLIT_V1 : SLIT_V2
			const spread = isObserved ? 0.01 : 0.04  // tight for particle, wider for wave
			photons.push({
				u:    BARRIER_U + BARRIER_HW + 0.02,
				v:    slitV + (Math.random() - 0.5) * SLIT_HH * 2,
				vu:   0.012 + Math.random() * 0.008,
				vv:   isObserved ? 0 : (Math.random() - 0.5) * 0.006,
				life: 1.0,
				slit: slitV
			})
			if (photons.length > MAX_PHOTONS) photons.shift()
		}

		function updatePhotons() {
			for (let i = photons.length - 1; i >= 0; i--) {
				const p = photons[i]
				p.u += p.vu
				p.v += p.vv
				p.life -= 0.012
				if (p.u > 1.05 || p.life <= 0) photons.splice(i, 1)
			}
		}

		// ─────────────────────────────────────────
		//  Render frame (SDF + wave interference)
		// ─────────────────────────────────────────
		function renderFrame(time) {

			const t = time * 0.001   // seconds

			// Smooth blend toward target (slow enough to be glitch-free)
			const target = isObserved ? 1 : 0
			observeBlend += (target - observeBlend) * 0.025

			const imgData = ctx.createImageData(W, H)
			const px = imgData.data
			const pxSize = 2.0 / W   // pixel size in normalised coords

			for (let j = 0; j < H; j++) {
				for (let i = 0; i < W; i++) {

					// Normalised coords -1 … +1
					const u = (i / (W - 1)) * 2.0 - 1.0
					const v = (j / (H - 1)) * 2.0 - 1.0
					const pi = (j * W + i) * 4

					let r = 0, g = 0, b = 0

					// ── 1) Barrier with slits (SDF) ──
					let dBarrier = sdBox(u, v, BARRIER_U, 0, BARRIER_HW, 1.05)
					const dSlit1 = sdBox(u, v, BARRIER_U, SLIT_V1, BARRIER_HW + 0.03, SLIT_HH)
					const dSlit2 = sdBox(u, v, BARRIER_U, SLIT_V2, BARRIER_HW + 0.03, SLIT_HH)
					dBarrier = opSubtraction(dSlit1, dBarrier)
					dBarrier = opSubtraction(dSlit2, dBarrier)

					const barrierMask = smoothstep(pxSize, -pxSize, dBarrier)

					// ── 2) Source emitter glow ──
					const dSource = sdBox(u, v, SOURCE_U, 0, 0.04, 0.5)
					const sourceMask = smoothstep(pxSize * 2, -pxSize, dSource)
					const sourceGlow = (Math.sin(t * 3.0 + v * 8.0) * 0.15 + 0.85)

					// ── 3) Detection area (right of barrier) ──
					const rightMask = smoothstep(BARRIER_U + BARRIER_HW - 0.02,
					                             BARRIER_U + BARRIER_HW + 0.08, u)

					// Distance from each slit centre (in normalised space)
					const du1 = u - BARRIER_U, dv1 = v - SLIT_V1
					const dist1 = Math.sqrt(du1 * du1 + dv1 * dv1)
					const du2 = u - BARRIER_U, dv2 = v - SLIT_V2
					const dist2 = Math.sqrt(du2 * du2 + dv2 * dv2)

					// ── WAVE mode (not observed): travelling wave interference ──
					const wave1 = Math.cos(dist1 * WAVE_K - t * WAVE_SPEED)
					const wave2 = Math.cos(dist2 * WAVE_K - t * WAVE_SPEED)
					// Superposition → interference
					const interference = (wave1 + wave2) * 0.5  // -1 … +1
					const waveIntensity = (interference * 0.5 + 0.5)

					// Envelope: attenuate with distance so it fades naturally
					const env = Math.exp(-dist1 * 0.7) + Math.exp(-dist2 * 0.7)
					const waveBright = waveIntensity * saturate(env) * rightMask

					// ── PARTICLE mode (observed): two Gaussian bands ──
					const sig = 0.09
					const g1 = Math.exp(-(v - SLIT_V1) * (v - SLIT_V1) / (2 * sig * sig))
					const g2 = Math.exp(-(v - SLIT_V2) * (v - SLIT_V2) / (2 * sig * sig))
					const partBright = Math.max(g1, g2) * rightMask *
					                   smoothstep(0.0, 0.3, u - BARRIER_U)

					// ── Blend wave ↔ particle ──
					const pattern = lerp(waveBright, partBright, observeBlend)

					// ── Colour palette ──
					//   wave  → cyan / blue
					//   particle → warm amber / red
					const cr = lerp(5,   230, observeBlend)
					const cg = lerp(160,  60, observeBlend)
					const cb = lerp(255,  30, observeBlend)

					// Combine layers
					r = cr * pattern
					g = cg * pattern
					b = cb * pattern

					// Barrier: dark blue-grey, bright edge highlight
					const edgeGlow = smoothstep(pxSize * 3, 0, dBarrier) * (1 - barrierMask) * 0.25
					r = lerp(r, 18, barrierMask) + edgeGlow * 80
					g = lerp(g, 18, barrierMask) + edgeGlow * 90
					b = lerp(b, 28, barrierMask) + edgeGlow * 120

					// Slit openings: faint glow when waves pass through
					const slitGlow1 = smoothstep(pxSize * 2, -pxSize, dSlit1)
					const slitGlow2 = smoothstep(pxSize * 2, -pxSize, dSlit2)
					const slitFlicker = Math.sin(t * WAVE_SPEED) * 0.3 + 0.5
					const slitG = (slitGlow1 + slitGlow2) * slitFlicker * 0.3
					r += slitG * lerp(40, 180, observeBlend)
					g += slitG * lerp(100, 50, observeBlend)
					b += slitG * lerp(160, 20, observeBlend)

					// Source emitter
					r += sourceMask * sourceGlow * lerp(50, 80, observeBlend)
					g += sourceMask * sourceGlow * lerp(90, 50, observeBlend)
					b += sourceMask * sourceGlow * lerp(180, 40, observeBlend)

					// Incoming beam (between source and barrier)
					if (u > SOURCE_U + 0.06 && u < BARRIER_U - BARRIER_HW) {
						const beamY = Math.abs(v)
						const beam = Math.exp(-beamY * beamY / (2 * 0.35 * 0.35))
						const beamPulse = Math.sin(u * 30.0 - t * WAVE_SPEED) * 0.3 + 0.5
						const beamI = beam * beamPulse * 0.25
						r += beamI * lerp(40, 100, observeBlend)
						g += beamI * lerp(80, 40, observeBlend)
						b += beamI * lerp(180, 30, observeBlend)
					}

					px[pi + 0] = Math.min(255, Math.max(0, Math.floor(r)))
					px[pi + 1] = Math.min(255, Math.max(0, Math.floor(g)))
					px[pi + 2] = Math.min(255, Math.max(0, Math.floor(b)))
					px[pi + 3] = 255
				}
			}

			// ── Photon particles (additive) ──
			if (frame % 3 === 0) spawnPhoton()
			updatePhotons()

			for (const p of photons) {
				// Photon → pixel coords
				const px0 = Math.round((p.u + 1) * 0.5 * (W - 1))
				const py0 = Math.round((p.v + 1) * 0.5 * (H - 1))
				if (px0 < 0 || px0 >= W || py0 < 0 || py0 >= H) continue

				const bright = p.life * p.life  // quadratic falloff
				const pi = (py0 * W + px0) * 4

				// In wave mode: photons are dimmer, cyan tinted
				// In particle mode: bright warm dots
				const pr = lerp(80, 255, observeBlend) * bright
				const pg = lerp(160, 200, observeBlend) * bright
				const pb = lerp(220, 100, observeBlend) * bright

				px[pi + 0] = Math.min(255, px[pi + 0] + Math.floor(pr))
				px[pi + 1] = Math.min(255, px[pi + 1] + Math.floor(pg))
				px[pi + 2] = Math.min(255, px[pi + 2] + Math.floor(pb))
			}

			ctx.putImageData(imgData, 0, 0)
		}

		// ─────────────────────────────────────────
		//  Main Loop
		// ─────────────────────────────────────────
		const FPS = { frames: 0, ptime: 0, fps: 0, tick(t) {
			this.frames++
			if (t >= this.ptime + 1000) {
				this.fps = this.frames * 1000 / (t - this.ptime)
				this.ptime = t; this.frames = 0
			}
			return this.fps
		}}

		requestAnimationFrame(loop)

		async function loop(time) {
			requestAnimationFrame(loop)

			// Throttle
			const delta = time - timeSample
			const interval = 1000 / TARGET_FPS
			if (delta < interval) return
			timeSample = time - delta % interval

			document.title = 'FPS: ' + FPS.tick(time).toFixed(1)

			// ── Render ──
			renderFrame(time)
			frame++

			// ── Send to matrix via serial ──
			if (!writer) return
			if (writing) return   // skip frame if previous write still in flight

			// Get pixel data from canvas
			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			const pixels = imageData.data;

			try {
				// Send pixel data
				// The first byte is a magic number to identify the data format
				PIXEL_DATA[0] = 42
				let idx = 1 // Start at the second byte

				for (let i = 0; i < pixels.length; i += 4) {
					const r = pixels[i + 0]
					const g = pixels[i + 1]
					const b = pixels[i + 2]
					const rgb16 = packRGB16(r, g, b)
					const [highByte, lowByte] = splitBytes(rgb16)
					PIXEL_DATA[idx++] = highByte
					PIXEL_DATA[idx++] = lowByte
				}

				writing = true
				await writer.write(PIXEL_DATA)
				writing = false

			} catch (err) {
				writing = false
				const error = 'Error in draw loop: ' + err
				console.error(error)
				appendLog(error)
			}
		}

		// ─────────────────────────────────────────
		//  Helpers
		// ─────────────────────────────────────────
		function packRGB16(r, g, b) {
			return ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3)
		}

		function splitBytes(v) {
			return [(v >> 8) & 0xFF, v & 0xFF]
		}

		function appendLog(msg) {
			logEl.textContent += '\n' + msg
			logEl.scrollTop = logEl.scrollHeight
		}

	</script>
</body>
</html>
